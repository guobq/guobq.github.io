<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="bq,undefined"><meta name="copyright" content="bq"><title>【bq's notes】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"8ICB0LL54F","apiKey":"b6e01221a0e1bdb34d69e088b9bd39d8","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {"appId":"8xUuEcUoXahLwm69LVK1eumF-gzGzoHsz","appKey":"NDF5dcJsxuEHHBOLlda7Y07b"},
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="bq's notes" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">bq</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/guobq" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:2278220079@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2278220079&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">78</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">80</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">25</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">bq's notes</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/5b6c7637.html">windows设置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-09-18</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E9%80%9A%E7%94%A8/">通用</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E9%80%9A%E7%94%A8/%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%85%8D%E7%BD%AE/">工具与配置</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/windows%E8%AE%BE%E7%BD%AE/">windows设置</a></div></div><div class="post-content"><div class="main-content content"><h3 id="无拓展名文件设置默认打开方式"><a href="#无拓展名文件设置默认打开方式" class="headerlink" title="无拓展名文件设置默认打开方式"></a>无拓展名文件设置默认打开方式</h3><p>cmd中，assoc用来关联后缀与文件类型，ftype用来关联文件类型和打开其的应用程序。</p>
<p>设置关联文件类型</p>
<p>管理员状态下运行cmd，查看无拓展的关联类型：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assoc</span>  .</span><br></pre></td></tr></table></figure>

<p>自定义无后缀文件对应的文件类型（此处为<code>No Extension</code>,可以自定义,注意在等号后面是没有空格的！）,设置关联：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assoc</span> .=No Extension</span><br></pre></td></tr></table></figure>

<p>设置关联（此处我使用vscode，可以把路径替换为其他程序），输入：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ftype</span> &quot;No Extension&quot;=&quot;D:\software\Microsoft VS Code\Code.exe&quot; &quot;%<span class="number">1</span>&quot;</span><br></pre></td></tr></table></figure>

<h3 id="批处理文件-bat-后台运行"><a href="#批处理文件-bat-后台运行" class="headerlink" title="批处理文件 bat 后台运行"></a>批处理文件 bat 后台运行</h3><p>方案一:批处理文件,开头加上以下三行代码</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;hide&quot; <span class="keyword">goto</span> CmdBegin</span><br><span class="line"><span class="built_in">start</span> mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~<span class="number">0</span>&quot;&quot; hide&quot;,<span class="number">0</span>)(window.close)&amp;&amp;<span class="keyword">exit</span></span><br><span class="line">:CmdBegin</span><br></pre></td></tr></table></figure>

<p>方案二:再创建一个backrun.vbs文件,写入以下代码</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createobject(&quot;wscript.shell&quot;).run &quot;test.bat&quot;,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>双击该该vbs文件,批处理文件,就进入后台运行模式了;打开资源管理器, 会发现有一个cmd的进程,就是批处理文件的进程</p>
<h3 id="Spreadsheet-compare-2016崩溃解决"><a href="#Spreadsheet-compare-2016崩溃解决" class="headerlink" title="Spreadsheet compare 2016崩溃解决"></a>Spreadsheet compare 2016崩溃解决</h3><p>注册表中找到[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\16.0\Common\Identity]位置下添加：<br>“EnableADAL”=dword:00000000<br>Spreadsheet compare工具下载地址：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/spreadshcompare/">https://sourceforge.net/projects/spreadshcompare/</a></p>
</div></div><a class="button-hover more" href="/bq/5b6c7637.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/4409411c.html">命令行交互方式来访问HTTP服务(curl&amp;httpie)</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-04-11</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Test/">Test</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Test/tool/">tool</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/curl/">curl</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/httpie/">httpie</a></div></div><div class="post-content"><div class="main-content content"><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>用于命令行和脚本进行传输数据到服务器或者从服务器传输数据的工具</p>
<ul>
<li><p>支持广泛的协议，如：ftp、http、https、pop3、scp、sftp、telent等</p>
</li>
<li><p>支持SSL证书，HTTP中各方法、cookies、head、authentication</p>
</li>
<li><p>免费开源软件</p>
<p>使用场景：</p>
</li>
<li><p>请求、验证、测试链接</p>
</li>
<li><p>支持连接超时、保活时间设置，支持下载上传速率的配置，支持重试机制等</p>
</li>
<li><p>测试restful接口</p>
</li>
<li><p>上传、下载文件</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>curl [options] [URL…]</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>-V</td>
<td align="left">显示当前的curl版本</td>
</tr>
<tr>
<td>-#</td>
<td align="left">对发送和接收进行简单的进度bar展示</td>
</tr>
<tr>
<td>-0</td>
<td align="left">强制使用HTTP 1.0协议</td>
</tr>
<tr>
<td>-1</td>
<td align="left">强制使用TLS version 1.x</td>
</tr>
<tr>
<td>-4</td>
<td align="left">解析域名为ipv4地址(域名有多个ip时)</td>
</tr>
<tr>
<td>-a</td>
<td align="left">FTP/SFTP上传文件时，curl将追加到目标文件，而非覆盖</td>
</tr>
<tr>
<td>-A</td>
<td align="left">设置用户代理</td>
</tr>
<tr>
<td>-b</td>
<td align="left">设置cookies</td>
</tr>
<tr>
<td>–basic</td>
<td align="left">使用HTTP Basic authentication</td>
</tr>
<tr>
<td>–compressed</td>
<td align="left">使用curl支持的压缩算法请求压缩的响应， 如果请求的响应不是压缩的，curl抛出异常</td>
</tr>
<tr>
<td>–connect-timeout</td>
<td align="left">设置连接超时时间</td>
</tr>
<tr>
<td>-d</td>
<td align="left">用于post请求时表单提交数据， 请求类型将被设置为：application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>-e</td>
<td align="left">发送”Referer Page”到服务器</td>
</tr>
<tr>
<td>-F</td>
<td align="left">form表单提交</td>
</tr>
<tr>
<td>-G</td>
<td align="left">使用get请求发送 -d参数指定的数据</td>
</tr>
<tr>
<td>-H</td>
<td align="left">增加Head头</td>
</tr>
<tr>
<td>-i</td>
<td align="left">在输出Head头（响应）</td>
</tr>
<tr>
<td>-I</td>
<td align="left">只输出Head头（响应）</td>
</tr>
<tr>
<td>–interface</td>
<td align="left">指定使用的网络接口</td>
</tr>
<tr>
<td>-k</td>
<td align="left">允许curl使用非安全的ssl连接并且传输数据（证书不受信）</td>
</tr>
<tr>
<td>-K</td>
<td align="left">后接参数文件，参数文件中可以定义HTTP请求的相关的内容（URL、HEAD、DATA）</td>
</tr>
<tr>
<td>–keepalive-time</td>
<td align="left">设置连接的保活时间</td>
</tr>
<tr>
<td>-L</td>
<td align="left">curl自动重定向（3xx）</td>
</tr>
<tr>
<td>–limit-rate</td>
<td align="left">特指最大的传输速率</td>
</tr>
<tr>
<td>-m</td>
<td align="left">设置整个操作的允许消耗的最大时间，对于在延时网络下的批量操作有利</td>
</tr>
<tr>
<td>–max-filesize</td>
<td align="left">允许下载文件的最大大小</td>
</tr>
<tr>
<td>-N</td>
<td align="left">禁用输出流缓冲区</td>
</tr>
<tr>
<td>–no-keepalive</td>
<td align="left">连接不保活</td>
</tr>
<tr>
<td>-o</td>
<td align="left">将响应数据输出到指定文件，后接文件参数</td>
</tr>
<tr>
<td>–retry</td>
<td align="left">发生瞬时错误时，curl将重试执行数据传输</td>
</tr>
<tr>
<td>–retry-delay</td>
<td align="left">延迟重试</td>
</tr>
<tr>
<td>–trace</td>
<td align="left">dump出输入输出数据至文件</td>
</tr>
<tr>
<td>-v</td>
<td align="left">获取更多输入输出相关的内容，对于debug非常有用</td>
</tr>
<tr>
<td>-y或者–speed-time</td>
<td align="left">如果在speed-time期间，下载比speed-limit这个更慢，则下载废止</td>
</tr>
<tr>
<td>-Y或者–speed-limit</td>
<td align="left">如果在speed-time期间，下载比speed-limit这个更慢，则下载废止</td>
</tr>
</tbody></table>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i表示显示返回消息的头部</span></span><br><span class="line">curl -X METHOD -H HEADER -i </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d后面表示请求消息体，如果消息体在文件中，那么使用@符号作为前缀对文件进行读取</span></span><br><span class="line">curl -i -X POST -H &quot;Content-Type: application/json&quot; -d @auth.json http://host:port/v3/auth/tokens</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不带有任何参数时，curl 就是发出 GET 请求。</span></span><br><span class="line">curl https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash">上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。</span></span><br><span class="line">curl -A &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将User-Agent改成 Chrome 浏览器。</span></span><br><span class="line">curl -A &#x27;&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令会移除User-Agent标头。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以通过-H参数直接指定标头，更改User-Agent。</span></span><br><span class="line">curl -H &#x27;User-Agent: php/1.0&#x27; https://google.com </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b参数用来向服务器发送 Cookie。</span></span><br><span class="line">curl -b &#x27;foo=bar&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。</span></span><br><span class="line">curl -b &#x27;foo1=bar&#x27; -b &#x27;foo2=baz&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令发送两个 Cookie。</span></span><br><span class="line">curl -b cookies.txt https://www.google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c参数将服务器设置的 Cookie 写入一个文件。</span></span><br><span class="line">curl -c cookies.txt https://www.google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C switch是恢复我们文件传输的设备，但还要注意，它后面紧跟一个破折号（-）。这告诉cURL继续文件传输，但是实现这一步，首先要查看已经下载的部分，找到下载的最后一个字节才可以确定从何处可以恢复。</span></span><br><span class="line">curl -C - example.com/some-file.zip --output MyFile.zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d参数用于发送 POST 请求的数据体。</span></span><br><span class="line">curl -d&#x27;login=emma＆password=123&#x27;-X POST https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST  https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d参数可以读取本地文本文件的数据，向服务器发送。</span></span><br><span class="line">curl -d &#x27;@data.txt&#x27; https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令读取data.txt文件的内容，作为数据体向服务器发送。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</span></span><br><span class="line">curl --data-urlencode &#x27;comment=hello world&#x27; https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e参数用来设置 HTTP 的标头Referer，表示请求的来源。</span></span><br><span class="line">curl -e &#x27;https://google.com?q=example&#x27; https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将Referer标头设为https://google.com?q=example。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -H参数可以通过直接添加标头Referer，达到同样效果。</span></span><br><span class="line">curl -H &#x27;Referer: https://google.com?q=example&#x27; https://www.example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -F参数用来向服务器上传二进制文件。</span></span><br><span class="line">curl -F &#x27;file=@photo.png&#x27; https://google.com/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -F参数可以指定 MIME 类型。</span></span><br><span class="line">curl -F &#x27;file=@photo.png;type=image/png&#x27; https://google.com/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -F参数也可以指定文件名。</span></span><br><span class="line">curl -F &#x27;file=@photo.png;filename=me.png&#x27; https://google.com/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -G参数用来构造 URL 的查询字符串。</span></span><br><span class="line">curl -G -d &#x27;q=kitties&#x27; -d &#x27;count=20&#x27; https://google.com/search</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果数据需要 URL 编码，可以结合--data--urlencode参数。</span></span><br><span class="line">curl -G --data-urlencode &#x27;comment=hello world&#x27; https://www.example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -H参数添加 HTTP 请求的标头。</span></span><br><span class="line">curl -H &#x27;Accept-Language: en-US&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令添加 HTTP 标头Accept-Language: en-US。</span></span><br><span class="line">curl -H &#x27;Accept-Language: en-US&#x27; -H &#x27;Secret-Message: xyzzy&#x27; https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令添加两个 HTTP 标头。</span></span><br><span class="line">curl -d &#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i参数打印出服务器回应的 HTTP 标头。</span></span><br><span class="line">curl -i https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。</span></span><br><span class="line">curl -I https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令输出服务器对 HEAD 请求的回应。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --head参数等同于-I。</span></span><br><span class="line">curl --head https://www.example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -k参数指定跳过 SSL 检测。</span></span><br><span class="line">curl -k https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令不会检查服务器的 SSL 证书是否正确。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</span></span><br><span class="line">curl -L -d &#x27;tweet=hi&#x27; https://api.twitter.com/tweet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</span></span><br><span class="line">curl --limit-rate 200k https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将带宽限制在每秒 200K 字节。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m switch指定执行命令所需的最长时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 经过指定的时间后，cURL将退出正在执行的操作，即使它正在下载或上传文件。cURL会以秒为单位指定您想要的最长时间。因此，要在一分钟后超时，该命令将如下所示：</span></span><br><span class="line">curl -m 60 example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 您可以使用cURL指定的另一种超时类型是用于链接的时间量。这有助于确保cURL不会花费过多的时间来尝试连接处于脱机状态或无法访问的主机。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 它也接受秒作为参数。该选项被写为–connect-timeout。</span></span><br><span class="line">curl --connect-timeout 60 example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -o,  --output</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -o参数将服务器的回应保存成文件，等同于wget命令。</span></span><br><span class="line">curl -o example.html https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将www.example.com保存成example.html。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</span></span><br><span class="line">curl -O https://www.example.com/foo/bar.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令将服务器回应保存成文件，文件名为bar.html。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s参数将不输出错误和进度信息。</span></span><br><span class="line">curl -s https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想让 curl 不产生任何输出，可以使用下面的命令。</span></span><br><span class="line">curl -s -o /dev/null https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> -S参数指定只输出错误信息，通常与-o一起使用。</span></span><br><span class="line">curl -s -o /dev/null https://google.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令没有任何输出，除非发生错误。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -u参数用来设置服务器认证的用户名和密码。</span></span><br><span class="line">curl -u &#x27;bob:12345&#x27; https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> curl 能够识别 URL 里面的用户名和密码。</span></span><br><span class="line">curl https://bob:12345@google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</span></span><br><span class="line">curl -u &#x27;bob&#x27; https://google.com/login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v参数输出通信的整个过程，用于调试。</span></span><br><span class="line">curl -v https://www.example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --trace参数也可以用于调试，还会输出原始的二进制数据。</span></span><br><span class="line">curl --trace - https://www.example.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x参数指定 HTTP 请求的代理。</span></span><br><span class="line">curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有指定代理协议，默认为 HTTP。</span></span><br><span class="line">curl -x james:cats@myproxy.com:8080 https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令中，请求的代理使用 HTTP 协议。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -X参数指定 HTTP 请求的方法。</span></span><br><span class="line">curl -X POST https://www.example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面命令对https://www.example.com发出 POST 请求。</span></span><br></pre></td></tr></table></figure>

<p>ex：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -k -x &#x27;http://127.0.0.1:8888&#x27; &#x27;https://www.jianshu.com/shakespeare/notes/31762521/user_notes&#x27; \</span><br><span class="line">  -H &#x27;Connection: keep-alive&#x27; \</span><br><span class="line">  -H &#x27;Accept: application/json&#x27; \</span><br><span class="line">  -H &#x27;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Site: same-origin&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Mode: cors&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Dest: empty&#x27; \</span><br><span class="line">  -H &#x27;Referer: https://www.jianshu.com/p/9f9c5cba36e8&#x27; \</span><br><span class="line">  -H &#x27;Accept-Language: zh-CN,zh;q=0.9&#x27; \</span><br><span class="line">  -H &#x27;Cookie: __yadk_uid=Ein4n8jn6l5P6GObqMAXjgWVHPQddHrg; _ga=GA1.2.1043383107.1597137593; _gid=GA1.2.1914484739.1597137593; web_login_version=MTU5NzQ4MzUwMw%3D%3D--5dbb5619f4070e31714c813c4eccafb00f0ed003; remember_user_token=W1sxNTAzNjgyMl0sIiQyYSQxMSQzbHZDZTBQLnFZVWpvak00SzFydlNPIiwiMTU5ODQ1MzAxMS44MjQ3NjQiXQ%3D%3D--0d91c3663c7ac2048e7f7cbc941b9f66ca3f3a88; _m7e_session_core=7b490b8cfcf97f08559f60d68f9a0258; read_mode=day; default_font=font2; locale=zh-CN; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%22173dcd19edbafb-00bf4f7297fa3c-4353760-1327104-173dcd19edc8bc%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22httpbin%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Fs%22%2C%22%24latest_utm_source%22%3A%22recommendation%22%2C%22%24latest_utm_medium%22%3A%22seo_notes%22%2C%22%24latest_utm_campaign%22%3A%22maleskine%22%2C%22%24latest_utm_content%22%3A%22note%22%7D%2C%22%24device_id%22%3A%22173dcd19edbafb-00bf4f7297fa3c-4353760-1327104-173dcd19edc8bc%22%7D; _gat=1; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1598408433,1598413603,1598453016,1598460218; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1598460218&#x27; \</span><br><span class="line">  -H &#x27;If-None-Match: W/&quot;b97803d19320e20eed0659fcda4b0957&quot;&#x27; \</span><br><span class="line">  --compressed</span><br></pre></td></tr></table></figure>

<h3 id="CURL状态码列表"><a href="#CURL状态码列表" class="headerlink" title="CURL状态码列表"></a><strong>CURL状态码列表</strong></h3><table>
<thead>
<tr>
<th>状态码</th>
<th>状态原因</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>正常访问</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>错误的协议</td>
<td>未支持的协议。此版cURL 不支持这一协议。</td>
</tr>
<tr>
<td>2</td>
<td>初始化代码失败</td>
<td>初始化失败。</td>
</tr>
<tr>
<td>3</td>
<td>URL格式不正确</td>
<td>URL 格式错误。语法不正确。</td>
</tr>
<tr>
<td>4</td>
<td>请求协议错误</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>无法解析代理</td>
<td>无法解析代理。无法解析给定代理主机。</td>
</tr>
<tr>
<td>6</td>
<td>无法解析主机地址</td>
<td>无法解析主机。无法解析给定的远程主机。</td>
</tr>
<tr>
<td>7</td>
<td>无法连接到主机</td>
<td>无法连接到主机。</td>
</tr>
<tr>
<td>8</td>
<td>远程服务器不可用</td>
<td>FTP 非正常的服务器应答。cURL 无法解析服务器发送的数据。</td>
</tr>
<tr>
<td>9</td>
<td>访问资源错误</td>
<td>FTP 访问被拒绝。服务器拒绝登入或无法获取您想要的特定资源或目录。最有可 能的是您试图进入一个在此服务器上不存在的目录。</td>
</tr>
<tr>
<td>11</td>
<td>FTP密码错误</td>
<td>FTP 非正常的PASS 回复。cURL 无法解析发送到PASS 请求的应答。</td>
</tr>
<tr>
<td>13</td>
<td>结果错误</td>
<td>FTP 非正常的的PASV 应答，cURL 无法解析发送到PASV 请求的应答。</td>
</tr>
<tr>
<td>14</td>
<td>FTP回应PASV命令</td>
<td>FTP 非正常的227格式。cURL 无法解析服务器发送的227行。</td>
</tr>
<tr>
<td>15</td>
<td>内部故障</td>
<td>FTP 无法连接到主机。无法解析在227行中获取的主机IP。</td>
</tr>
<tr>
<td>17</td>
<td>设置传输模式为二进制</td>
<td>FTP 无法设定为二进制传输。无法改变传输方式到二进制。</td>
</tr>
<tr>
<td>18</td>
<td>文件传输短或大于预期</td>
<td>部分文件。只有部分文件被传输。</td>
</tr>
<tr>
<td>19</td>
<td>RETR命令传输完成</td>
<td>FTP 不能下载/访问给定的文件， RETR (或类似)命令失败。</td>
</tr>
<tr>
<td>21</td>
<td>命令成功完成</td>
<td>FTP quote 错误。quote 命令从服务器返回错误。</td>
</tr>
<tr>
<td>22</td>
<td>返回正常</td>
<td>HTTP 找不到网页。找不到所请求的URL 或返回另一个HTTP 400或以上错误。 此返回代码只出现在使用了-f/–fail 选项以后。</td>
</tr>
<tr>
<td>23</td>
<td>数据写入失败</td>
<td>写入错误。cURL 无法向本地文件系统或类似目的写入数据。</td>
</tr>
<tr>
<td>25</td>
<td>无法启动上传</td>
<td>FTP 无法STOR 文件。服务器拒绝了用于FTP 上传的STOR 操作。</td>
</tr>
<tr>
<td>26</td>
<td>回调错误</td>
<td>读错误。各类读取问题。</td>
</tr>
<tr>
<td>27</td>
<td>内存分配请求失败</td>
<td>内存不足。内存分配请求失败。</td>
</tr>
<tr>
<td>28</td>
<td>访问超时</td>
<td>操作超时。到达指定的超时期限条件。</td>
</tr>
<tr>
<td>30</td>
<td>FTP端口错误</td>
<td>FTP PORT 失败。PORT 命令失败。并非所有的FTP 服务器支持PORT 命令，请 尝试使用被动(PASV)传输代替！</td>
</tr>
<tr>
<td>31</td>
<td>FTP错误</td>
<td>FTP 无法使用REST 命令。REST 命令失败。此命令用来恢复的FTP 传输。</td>
</tr>
<tr>
<td>33</td>
<td>不支持请求</td>
<td>HTTP range 错误。range “命令”不起作用。</td>
</tr>
<tr>
<td>34</td>
<td>内部发生错误</td>
<td>HTTP POST 错误。内部POST 请求产生错误。</td>
</tr>
<tr>
<td>35</td>
<td>SSL/TLS握手失败</td>
<td>SSL 连接错误。SSL 握手失败。</td>
</tr>
<tr>
<td>36</td>
<td>下载无法恢复</td>
<td>FTP 续传损坏。不能继续早些时候被中止的下载。</td>
</tr>
<tr>
<td>37</td>
<td>文件权限错误</td>
<td>文件无法读取。无法打开文件。权限问题？</td>
</tr>
<tr>
<td>38</td>
<td>LDAP可没有约束力</td>
<td>LDAP 无法绑定。LDAP 绑定(bind)操作失败。</td>
</tr>
<tr>
<td>39</td>
<td>LDAP搜索失败</td>
<td>LDAP 搜索失败。</td>
</tr>
<tr>
<td>41</td>
<td>函数没有找到</td>
<td>功能无法找到。无法找到必要的LDAP 功能。</td>
</tr>
<tr>
<td>42</td>
<td>中止的回调</td>
<td>由回调终止。应用程序告知cURL 终止运作。</td>
</tr>
<tr>
<td>43</td>
<td>内部错误</td>
<td>内部错误。由一个不正确参数调用了功能。</td>
</tr>
<tr>
<td>45</td>
<td>接口错误</td>
<td>接口错误。指定的外发接口无法使用。</td>
</tr>
<tr>
<td>47</td>
<td>过多的重定向</td>
<td>过多的重定向。cURL 达到了跟随重定向设定的最大限额跟</td>
</tr>
<tr>
<td>48</td>
<td>无法识别选项</td>
<td>指定了未知TELNET 选项。</td>
</tr>
<tr>
<td>49</td>
<td>TELNET格式错误</td>
<td>不合式的telnet 选项。</td>
</tr>
<tr>
<td>51</td>
<td>远程服务器的SSL证书</td>
<td>peer 的SSL 证书或SSH 的MD5指纹没有确定。</td>
</tr>
<tr>
<td>52</td>
<td>服务器无返回内容</td>
<td>服务器无任何应答，该情况在此处被认为是一个错误。</td>
</tr>
<tr>
<td>53</td>
<td>加密引擎未找到</td>
<td>找不到SSL 加密引擎。</td>
</tr>
<tr>
<td>54</td>
<td>设定默认SSL加密失败</td>
<td>无法将SSL 加密引擎设置为默认。</td>
</tr>
<tr>
<td>55</td>
<td>无法发送网络数据</td>
<td>发送网络数据失败。</td>
</tr>
<tr>
<td>56</td>
<td>衰竭接收网络数据</td>
<td>在接收网络数据时失败。</td>
</tr>
<tr>
<td>57</td>
<td></td>
<td></td>
</tr>
<tr>
<td>58</td>
<td>本地客户端证书</td>
<td>本地证书有问题。</td>
</tr>
<tr>
<td>59</td>
<td>无法使用密码</td>
<td>无法使用指定的SSL 密码。</td>
</tr>
<tr>
<td>60</td>
<td>凭证无法验证</td>
<td>peer 证书无法被已知的CA 证书验证。</td>
</tr>
<tr>
<td>61</td>
<td>无法识别的传输编码</td>
<td>无法辨识的传输编码。</td>
</tr>
<tr>
<td>62</td>
<td>无效的LDAP URL</td>
<td>无效的LDAP URL。</td>
</tr>
<tr>
<td>63</td>
<td>文件超过最大大小</td>
<td>超过最大文件尺寸。</td>
</tr>
<tr>
<td>64</td>
<td>FTP失败</td>
<td>要求的FTP 的SSL 水平失败。</td>
</tr>
<tr>
<td>65</td>
<td>倒带操作失败</td>
<td>发送此数据需要的回卷(rewind)失败。</td>
</tr>
<tr>
<td>66</td>
<td>SSL引擎失败</td>
<td>初始化SSL 引擎失败。</td>
</tr>
<tr>
<td>67</td>
<td>服务器拒绝登录</td>
<td>用户名、密码或类似的信息未被接受，cURL 登录失败。</td>
</tr>
<tr>
<td>68</td>
<td>未找到文件</td>
<td>在TFTP 服务器上找不到文件。</td>
</tr>
<tr>
<td>69</td>
<td>无权限</td>
<td>TFTP 服务器权限有问题。</td>
</tr>
<tr>
<td>70</td>
<td>超出服务器磁盘空间</td>
<td>TFTP 服务器磁盘空间不足。</td>
</tr>
<tr>
<td>71</td>
<td>非法TFTP操作</td>
<td>非法的TFTP 操作。</td>
</tr>
<tr>
<td>72</td>
<td>未知TFTP传输的ID</td>
<td>未知TFTP 传输编号(ID)。</td>
</tr>
<tr>
<td>73</td>
<td>文件已经存在</td>
<td>文件已存在(TFTP) 。</td>
</tr>
<tr>
<td>74</td>
<td>错误TFTP服务器</td>
<td>无此用户(TFTP) 。</td>
</tr>
<tr>
<td>75</td>
<td>字符转换失败</td>
<td>字符转换失败。</td>
</tr>
<tr>
<td>76</td>
<td>必须记录回调</td>
<td>需要字符转换功能。</td>
</tr>
<tr>
<td>77</td>
<td>CA证书权限</td>
<td>读SSL 证书出现问题(路径？访问权限？ ) 。</td>
</tr>
<tr>
<td>78</td>
<td>URL中引用资源不存在</td>
<td>URL 中引用的资源不存在。</td>
</tr>
<tr>
<td>79</td>
<td>错误发生在SSH会话</td>
<td>SSH 会话期间发生一个未知错误。</td>
</tr>
<tr>
<td>80</td>
<td>无法关闭SSL连接</td>
<td>未能关闭SSL 连接。</td>
</tr>
<tr>
<td>81</td>
<td>服务未准备</td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>无法载入CRL文件</td>
<td>无法加载CRL 文件，丢失或格式不正确(在7.19.0版中增加) 。</td>
</tr>
<tr>
<td>83</td>
<td>发行人检查失败</td>
<td>签发检查失败(在7.19.0版中增加) 。</td>
</tr>
</tbody></table>
<h3 id="HTTPie"><a href="#HTTPie" class="headerlink" title="HTTPie"></a>HTTPie</h3><p><a target="_blank" rel="noopener" href="https://github.com/httpie/httpie">https://github.com/httpie/httpie</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httpie</span><br></pre></td></tr></table></figure>

<p>HTTPie基于python编写，内部使用了Requests和Pygments库</p>
<p>HTTPie比cURL直观，默认输入和输出都是json格式 (而cURL必须要指定<code>-H &quot;Content-Type: application/json&quot;</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http POST http://host:port/v3/auth/tokens @auth.json</span><br><span class="line">http GET http://host:port/v2/xx/servers X-Auth-Token:xxx</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/bq/4409411c.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/77d2dea0.html">Linux创建swap</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Linux/%E9%85%8D%E7%BD%AE/">配置</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Linux/">Linux</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/swap/">swap</a></div></div><div class="post-content"><div class="main-content content"><h3 id="Linux创建swap"><a href="#Linux创建swap" class="headerlink" title="Linux创建swap"></a>Linux创建swap</h3><p>查看内存的情况（此时swap行为0）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p>初始时Swap 相关数据都是0。</p>
<h4 id="创建swap文件（本文创建了2G），并使之生效"><a href="#创建swap文件（本文创建了2G），并使之生效" class="headerlink" title="创建swap文件（本文创建了2G），并使之生效"></a>创建swap文件（本文创建了2G），并使之生效</h4><p>a.创建用于交换分区的文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/swapfile bs=1M count=2048</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：block_size、number_of_block 大小可以自定义，比如 bs=1M count=1024 代表设置 1G 大小 SWAP 分区。</span></span><br></pre></td></tr></table></figure>

<p>b.设置交换分区文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure>

<p>c.立即启用交换分区文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swapon /swapfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个命令可能会提示“swapon: /swapfile: insecure permissions 0644, 0600 suggested.”，意思是建议把swap设置成644或600权限。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时运行free -m会发现swap一列已经有数字了,就是上面第一次执行free -m 后的结果。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：如果在 /etc/rc.local 中有 swapoff -a 需要修改为 swapon -a</span></span><br></pre></td></tr></table></figure>


<p>在 /etc/fstab 中添加如下一行，使之永久生效（自动挂载）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<h4 id="修改-swpapiness-参数"><a href="#修改-swpapiness-参数" class="headerlink" title="修改 swpapiness 参数"></a>修改 swpapiness 参数</h4><p>在 Linux 系统中，可以通过查看 /proc/sys/vm/swappiness 内容的值来确定系统对 SWAP 分区的使用原则。当 swappiness 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 SWAP 分区。当 swappiness 内容的值为 100 时，表示积极地使用 SWAP 分区，并且把内存中的数据及时地置换到 SWAP 分区。<br>查看修改前为 0，需要在物理内存使用完毕后才会使用 SWAP 分区。<br>可以使用下述方法临时修改此参数，假设我们配置为空闲内存少于 10% 时才使用 SWAP 分区：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 10 &gt;/proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure>

<p>若需要永久修改此配置，在系统重启之后也生效的话，可以修改 /etc/sysctl.conf 文件，并增加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<h4 id="关闭-SWAP"><a href="#关闭-SWAP" class="headerlink" title="关闭 SWAP"></a>关闭 SWAP</h4><p>当系统出现内存不足时，开启 SWAP 可能会因频繁换页操作，导致 IO 性能下降。如果要关闭 SWAP，可以采用如下方法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、查询 SWAP 分区设置：</span></span><br><span class="line">free -m </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、使用命令swapoff 关闭 SWAP，比如：</span></span><br><span class="line">swapoff /mnt/swap</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、修改 /etc/fstab 文件，删除或注释相关配置，取消 SWAP 的自动挂载：</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"><span class="meta">#</span><span class="bash">/swapfile swap swap defaults 0 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、 通过 free -m 确认 SWAP 已经关闭。</span></span><br><span class="line">free -m</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、 swappiness 参数调整：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用下述方法临时修改此参数，这里配置为 0%：</span></span><br><span class="line">echo 0 &gt;/proc/sys/vm/swappiness</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若需要永久修改此配置，在系统重启之后也生效的话，可以修改 /etc/sysctl.conf文件，并增加以下内容：</span></span><br><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/bq/77d2dea0.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/1b437b47.html">抓包&amp;协议分析</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-04-11</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Test/">Test</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Test/tool/">tool</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http/">http</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8A%93%E5%8C%85/">抓包</a></div></div><div class="post-content"><div class="main-content content"><p>工具：charles, firebug, wireshark, burpsuite</p>
<h3 id="fiddler"><a href="#fiddler" class="headerlink" title="fiddler"></a>fiddler</h3><h4 id="https-www-telerik-com-download-fiddler"><a href="#https-www-telerik-com-download-fiddler" class="headerlink" title="https://www.telerik.com/download/fiddler"></a><a target="_blank" rel="noopener" href="https://www.telerik.com/download/fiddler">https://www.telerik.com/download/fiddler</a></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置Fiddler Options (配置完后记得要重启Fiddler)</span></span><br><span class="line">Capture HTTPS CONNECTS # 截获HTTPS</span><br><span class="line">Allow remote computers to connect # 是允许别的机器把HTTP/HTTPS请求发送到Fiddler上来，移动端</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤</span></span><br><span class="line">Filters tab</span><br><span class="line"><span class="meta">#</span><span class="bash"> 各种解码与加解密</span></span><br><span class="line">decode  TextWizard</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重发请求</span></span><br><span class="line">composer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置断点修改请求request</span></span><br><span class="line">1. 用浏览器打开登录界面  </span><br><span class="line">2. 打开Fiddler, 在命令行中输入bpu URL（rules-auto breakpoint-before breakpoint）https://xueqiu.com/snowman/login</span><br><span class="line">3. 输入错误的用户名和密码点击登录</span><br><span class="line">4. Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示。</span><br><span class="line">5. 结果是正确地登录了</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置断点修改Response</span></span><br><span class="line">第一种：</span><br><span class="line">打开Fiddler 点击Rules-&gt; Automatic Breakpoint  -&gt;After Response  (这种方法会中断所有的会话)</span><br><span class="line">消除:点击Rules-&gt; Automatic Breakpoint  -&gt;Disabled</span><br><span class="line">第二种:</span><br><span class="line">在命令行中输入命令:  bpafter www.xueqiu.com   (这种方法只会中断www.xueqiu.com)</span><br><span class="line">消除:在命令行中输入命令 bpafter,</span><br><span class="line"><span class="meta">#</span><span class="bash"> AutoResponder tab（修改会话拖到AutoResponder tab下）</span></span><br><span class="line">1. 打开首页，把的图片保存到本地，并且对图片做些修改。</span><br><span class="line">2. 打开Fiddler 找到一个图片的会话拖到AutoResponer Tab下</span><br><span class="line">3. 选择Enable automatic reaponses 和Unmatched requests passthrough</span><br><span class="line">4. 在下面的Rule Editor 下面选择 Find a file... 选择本地保存的图片.  最后点击Save 保存下。</span><br><span class="line">5. 再首页清除缓存, 你会看到首页的图片用的是本地的</span><br><span class="line"><span class="meta">#</span><span class="bash"> 弱网</span></span><br><span class="line">Rules → Performances → Simulate Modem Speeds</span><br><span class="line"><span class="meta">#</span><span class="bash"> 证书</span></span><br><span class="line">浏览器打开代理地址 FiddlerRoot certificate</span><br></pre></td></tr></table></figure>

<p>操作可参考:<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5NzgzODI5NA==&amp;mid=2454040445&amp;idx=1&amp;sn=d89068f8364fb20a42aed499255138cb&amp;chksm=872bbac4b05c33d226c4c76fd9e803c44c507e77cf4e60816ae40178f172fd5de0a96d73445c&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1582602447184&amp;sharer_shareid=9f552d705e74f07c1d8c9ac2eea73bc9&amp;key=0a2ec05589e15d483f615813291876556a0940749b209e06b13f3ba0ecf1cd6b1497d7399626902e039223df48ac2ca1bcb4460155711cd07890482f71ba7b512907ffc5219d5ab081010d771814dd9c&amp;ascene=1&amp;uin=Mjg1MzY3NzIyMA==&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=ATpRN0jDHMGmvtTm0OANNLk=&amp;pass_ticket=ZBoOawavfdCpscbTzY2mOurA9YuvdXXtCl52c5+ABJ2uG1VA3pHleAw7QL9XVJsz">https://mp.weixin.qq.com/s?__biz=MzA5NzgzODI5NA==&amp;mid=2454040445&amp;idx=1&amp;sn=d89068f8364fb20a42aed499255138cb&amp;chksm=872bbac4b05c33d226c4c76fd9e803c44c507e77cf4e60816ae40178f172fd5de0a96d73445c&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1582602447184&amp;sharer_shareid=9f552d705e74f07c1d8c9ac2eea73bc9&amp;key=0a2ec05589e15d483f615813291876556a0940749b209e06b13f3ba0ecf1cd6b1497d7399626902e039223df48ac2ca1bcb4460155711cd07890482f71ba7b512907ffc5219d5ab081010d771814dd9c&amp;ascene=1&amp;uin=Mjg1MzY3NzIyMA%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=ATpRN0jDHMGmvtTm0OANNLk%3D&amp;pass_ticket=ZBoOawavfdCpscbTzY2mOurA9YuvdXXtCl52c5%2BABJ2uG1VA3pHleAw7QL9XVJsz</a></p>
<h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h3><h4 id="特性-："><a href="#特性-：" class="headerlink" title="特性 ："></a>特性 ：</h4><p>代理,限速,重写请求和响应,⿊⽩名单,组建请求,重复请求</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载：<a target="_blank" rel="noopener" href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a></p>
<p>补丁：<a target="_blank" rel="noopener" href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p>
<p>默认替换路径：</p>
<p>macOS:/Applications/Charles.app/Contents/Java/charles.jar<br>Windows: C:\Program Files\Charles\lib\charles.jar</p>
<p>抓取Http请求包:<a target="_blank" rel="noopener" href="https://blog.csdn.net/abc6368765/article/details/81101976">https://blog.csdn.net/abc6368765/article/details/81101976</a></p>
<p>抓取Https请求包:<a target="_blank" rel="noopener" href="https://blog.csdn.net/abc6368765/article/details/81103002">https://blog.csdn.net/abc6368765/article/details/81103002</a></p>
<h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Charles 打不开 HTTPS ，显示您的连接不是私密连接</span><br><span class="line">将Charles的SSL Certificates添加到受信任根证书列表中，需要将证书添加到受信任根证书列表中</span><br><span class="line">重启电脑</span><br></pre></td></tr></table></figure>



<h5 id="⽹络模型与常见协议"><a href="#⽹络模型与常见协议" class="headerlink" title="⽹络模型与常见协议"></a>⽹络模型与常见协议</h5><p><img src="https://raw.githubusercontent.com/guobq/mysource/master/PictureBed/image-%E2%BD%B9%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE.png" alt="image-20200917000053060"></p>
<h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>target<br>url: protocol host port<br>request<br>request method:<br>get post put head<br>resource path<br>protocol version<br>header: host cookie user-agent<br>get query<br>post body：json xml form</p>
<h4 id="get-amp-post"><a href="#get-amp-post" class="headerlink" title="get&amp;post"></a>get&amp;post</h4><p>http的method字段<br>post可以附加body<br>通⽤server nginx apache默认不记录post body数据</p>
<h4 id="cookie-amp-session"><a href="#cookie-amp-session" class="headerlink" title="cookie&amp;session"></a>cookie&amp;session</h4><p>server -&gt; set-cookie -&gt; cookie -&gt; request with cookie<br>server -&gt;token -&gt; set-cookie token / query -&gt; request</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ⽹络嗅探</span></span><br><span class="line">TcpDump + WireShark</span><br><span class="line"><span class="meta">#</span><span class="bash"> Proxy</span></span><br><span class="line">fiddler 、AnyProxy 、mitmproxy、charles、burpsuite </span><br><span class="line"><span class="meta">#</span><span class="bash"> 分析⼯具与协议客户端⼯具:</span></span><br><span class="line">curl 最常使⽤的http请求⼯具</span><br><span class="line">postman 调试⼯具</span><br><span class="line">Chrome DevTool</span><br><span class="line">nc 接近于编程⽅式</span><br><span class="line">burpsuite http操纵的⿊客级别⼯具</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ⽹络嗅探</span></span><br><span class="line">TcpDump + WireShark</span><br><span class="line"><span class="meta">#</span><span class="bash"> Proxy</span></span><br><span class="line">fiddler 、AnyProxy 、mitmproxy、charles、burpsuite </span><br><span class="line"><span class="meta">#</span><span class="bash"> 分析⼯具与协议客户端⼯具:</span></span><br><span class="line">curl</span><br><span class="line">postman</span><br><span class="line">Chrome DevTool</span><br></pre></td></tr></table></figure>

<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 443 -v -w tcp.lg</span><br></pre></td></tr></table></figure>

<h3 id="移动端代理抓包"><a href="#移动端代理抓包" class="headerlink" title="移动端代理抓包"></a>移动端代理抓包</h3><p>开启代理端口<br>设置⼿机代理:Android 6.0以上需要修改包属性<a target="_blank" rel="noopener" href="https://developer.android.com/training/articles/securityconfig.html">https://developer.android.com/training/articles/securityconfig.html</a><br>安装证书<br>（从Android Nougat（7.0）开始，应⽤程序默认不会信任⽤户证书，开发⼈员可以通过配置应⽤程序AndroidManifest.xml⽂件的networkSecurityConfig属性来选择接受⽤户证书）</p>
<h3 id="数据拦截修改"><a href="#数据拦截修改" class="headerlink" title="数据拦截修改"></a>数据拦截修改</h3><p>修改请求，修改响应，断点，重写</p>
<h3 id="⾃定义代理解析特殊协议"><a href="#⾃定义代理解析特殊协议" class="headerlink" title="⾃定义代理解析特殊协议"></a>⾃定义代理解析特殊协议</h3><p>流量转发<br>协议解包<br>协议封包<br>原理是tcp proxy或者http proxy<br>参考⼯具 em-proxy nc</p>
</div></div><a class="button-hover more" href="/bq/1b437b47.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/c41a1599.html">redis搭建</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E9%80%9A%E7%94%A8/">通用</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E9%80%9A%E7%94%A8/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/">服务搭建</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/redis/">redis</a></div></div><div class="post-content"><div class="main-content content"><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar zxf  redis-5.0.8.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">cd redis-5.0.8</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装编译后的redis代码到指定目录,一般存放于/usr/<span class="built_in">local</span>下的redis目录,指令如下</span></span><br><span class="line">make install PREFIX=/usr/local/redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">./redis-server --port 6380&amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis默认只允许本地访问，要使redis可以远程访问可以修改redis.conf，注释掉<span class="built_in">bind</span> 127.0.0.1可以使所有的ip访问redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接</span></span><br><span class="line">./redis-cli -h 192.168.25.153 -p 6379</span><br></pre></td></tr></table></figure>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集群</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis的配置文件：修改端口号，打开cluster-enable前面的注释，修改cluster-config-file nodes.conf文件名</span></span><br><span class="line">./src/redis-server ../redis6.conf &amp; </span><br><span class="line">./src/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建6个redis实例（6个节点）并启动：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在usr/<span class="built_in">local</span>目录下新建redis-cluster目录，用于存放集群节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把redis目录下的bin目录下的所有文件复制到/usr/<span class="built_in">local</span>/redis-cluster/redis01目录下</span></span><br><span class="line">cp -r redis/bin/ redis-cluster/redis01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除redis01目录下的快照文件dump.rdb，并且修改该目录下的redis.cnf文件，修改端口号，打开cluster-enable前面的注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将redis-cluster/redis01文件复制5份到redis-cluster目录下（redis02-redis06），创建6个redis实例，模拟Redis集群的6个节点。然后将其余5个文件下的redis.conf里面的端口号分别修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动所有redis节点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要搭建集群的话，需要使用一个工具（脚本文件），这个工具在redis解压文件的源代码里。因为这个工具是一个ruby脚本文件，所以这个工具的运行需要ruby的运行环境</span></span><br><span class="line">yum install ruby</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后需要把ruby相关的包安装到服务器：redis的版本和ruby包的版本最好保持一致</span></span><br><span class="line">gem install redis-XXX.gem</span><br><span class="line"><span class="meta">#</span><span class="bash"> ruby脚本工具在redis解压文件的源代码里，即redis/src目录下的redis-trib.rb文件，复制到usr/<span class="built_in">local</span>/redis-cluster目录下。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搭建集群</span></span><br><span class="line">./redis-trib.rb  create --replicas  1 10.10.100.56:16449 10.10.100.56:16459 10.10.100.56:16469 10.10.100.56:16479 10.10.100.56:16489 10.10.100.56:16499 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接集群节点，连接任意一个即可，存储的数据（key-value）是均匀分配到不同的节点的：</span></span><br><span class="line">redis01/redis-cli -p 端口号 -c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前集群信息</span></span><br><span class="line">cluster info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群里有多少个节点</span></span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>
</div></div><a class="button-hover more" href="/bq/c41a1599.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/ca7c7e35.html">Java启动参数设置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-03</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Language/">Language</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Language/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jvm/">jvm</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a></div></div><div class="post-content"><div class="main-content content"><h3 id="Java启动参数设置"><a href="#Java启动参数设置" class="headerlink" title="Java启动参数设置"></a>Java启动参数设置</h3><p>Java启动参数共分为三类；<br>其一是标准参数（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容；<br>其二是非标准参数（-X），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；<br>其三是非Stable参数（-XX），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；</p>
<h4 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Java 默认/缺省 内存大小，如果没有 -Xms -Xmx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出默认值命令</span></span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=16336768 -XX:MaxHeapSize=522776576 -XX:+PrintCommandLineFlags</span><br><span class="line"><span class="meta">#</span><span class="bash"> -Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Xms和-Xmx可以说是最流行的JVM参数，它们可以允许我们指定JVM的初始和最大堆内存大小。一般来说，这两个参数的数值单位是Byte，但同时它们也支持使用速记符号，比如“k”或者“K”代表“kilo”，“m”或者“M”代表“mega”，“g”或者“G”代表“giga”。举个例子，下面的命令启动了一个初始化堆内存为128M，最大堆内存为2G，名叫“MyApp”的Java应用程序。</span></span><br><span class="line">java -Xms128m -Xmx2g MyApp</span><br><span class="line"><span class="meta">#</span><span class="bash"> example</span></span><br><span class="line">java -Xms32m -Xmx96m -jar $&#123;JARNAME&#125;*RELEASE.jar --spring.profiles.active=test&amp;</span><br></pre></td></tr></table></figure>

<p>jar包启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ai-registration-20170101.1.0.0.jar --server.port=9999 --spring.profiles.active=uat</span><br></pre></td></tr></table></figure>

<p>输出日志不挂断地运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar /home/mobiletest/workspace/iboss-ei-boss.jar --spring.profiles.active=uat&gt;ei.log&amp;</span><br></pre></td></tr></table></figure>







</div></div><a class="button-hover more" href="/bq/ca7c7e35.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/efdd0a04.html">gitlab安装</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-05-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">代码管理</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/gitlab/">gitlab</a></div></div><div class="post-content"><div class="main-content content"><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置yum源</span></span><br><span class="line">vi /etc/yum.repos.d/tsinghua.repo</span><br><span class="line"></span><br><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存相关包</span></span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装相关依赖</span></span><br><span class="line">yum install curl policycoreutils-python openssh-server </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装gitlab-ce</span></span><br><span class="line">yum install gitlab-ce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改gitlab配置文件指定服务器ip和自定义端口：</span></span><br><span class="line">vim  /etc/gitlab/gitlab.rb</span><br><span class="line">external_url=&#x27;http://122.51.139.130&#x27;</span><br><span class="line">unicorn[&#x27;port&#x27;] = 8888</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重置并启动GitLab</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改<span class="built_in">clone</span> host地址</span></span><br><span class="line">vi /var/opt/gitlab/gitlab-rails/etc/gitlab.yml</span><br><span class="line">122.51.139.130</span><br><span class="line">cat /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br><span class="line">gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试sshkey</span></span><br><span class="line">ssh -vT git@ip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用yum安装完gitLab，设置ssh key，在进行项目的<span class="built_in">clone</span></span></span><br><span class="line">git clone git@xxx/xxx.git #提示需要输入密码,这个密码并不是gitlab账户的密码，而是服务器git用户的密码。</span><br></pre></td></tr></table></figure>

<h4 id="question"><a href="#question" class="headerlink" title="question"></a>question</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最终决定登陆到gitlab服务器发现git用户为锁定状态，由于git账户是在安装gitlab时自动创建的，初始密码没有设置，用户锁定导致ssh连接不可用</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">1.首先切换到root用户： sudo su root</span><br><span class="line">2.输入有root权限的当前账户的密码（如果你已经在root账户下 1 2两步忽略）</span><br><span class="line">3.给git用户设置密码：passwd git </span><br><span class="line">4.按提示输入两遍新密码即可</span><br></pre></td></tr></table></figure>

<h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><h4 id="镜像拉取与启动"><a href="#镜像拉取与启动" class="headerlink" title="镜像拉取与启动"></a>镜像拉取与启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br><span class="line"><span class="meta">#</span><span class="bash">-i  以交互模式运行容器，通常与 -t 同时使用命令解释：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-t  为容器重新分配一个伪输入终端，通常与 -i 同时使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d  后台运行容器，并返回容器ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-p 9980:80  将容器内80端口映射至宿主机9980端口，这是访问gitlab的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-p 9922:22  将容器内22端口映射至宿主机9922端口，这是访问ssh的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-v /home/bq/docker/gitlab/etc:/etc/gitlab  将容器/etc/gitlab目录挂载到宿主机/home/bq/docker/gitlab/etc目录下，若宿主机内此目录不存在将会自动创建，其他两个挂载同这个一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--restart always  容器自启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--privileged=<span class="literal">true</span>  让容器获取宿主机root权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--name gitlab  设置容器名称为gitlab</span></span><br><span class="line"><span class="meta">#</span><span class="bash">gitlab/gitlab-ce  镜像的名称，这里也可以写镜像ID</span></span><br><span class="line">docker run \</span><br><span class="line"> -itd  \</span><br><span class="line"> -p 9980:80 \</span><br><span class="line"> -p 9922:22 \</span><br><span class="line"> -v /home/bq/docker/gitlab/etc:/etc/gitlab  \</span><br><span class="line"> -v /home/bq/docker/gitlab/log:/var/log/gitlab \</span><br><span class="line"> -v /home/bq/docker/gitlab/opt:/var/opt/gitlab \</span><br><span class="line"> --name gitlab \</span><br><span class="line"> gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">docker exec -it gitlab /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置</span></span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置生效</span></span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启gitlab </span></span><br><span class="line">gitlab-ctl restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器 </span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="关闭用户注册"><a href="#关闭用户注册" class="headerlink" title="关闭用户注册"></a>关闭用户注册</h4><p>1、使用root用户登录gitlab<br>2、点击【Admin Area】<br>3、点击【Settings】<br>4、点击Sign-in restrictions这一栏的【Expand】<br>5、取消勾选【Sign-up enabled】<br>6、保存修改</p>
<h4 id="优化精简git仓库"><a href="#优化精简git仓库" class="headerlink" title="优化精简git仓库"></a>优化精简git仓库</h4><p>清除垃圾文件(大量无用的mp3文件)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch *.mp3&#x27; --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>

<p>提交到远程仓库(如GitHub, 我再次从git clone GitHub代码库会变小为1.3M)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure>

<p>必须回收垃圾,本地仓库才变小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git for-each-ref --format=&#x27;delete %(refname)&#x27; refs/original | git update-ref --stdin   </span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">rm -rf .git/refs/original</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.统计仓库精简前容量信息,造成最大的文件pack记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看仓库容量信息:</span></span><br><span class="line">du -h --max-depth=1</span><br><span class="line"><span class="meta">#</span><span class="bash">找出最大的3个文件的pack记录:</span></span><br><span class="line">git verify-pack -v .git/objects/pack/pack-*.idx |sort -k 3 n | tail -3</span><br><span class="line"><span class="meta">#</span><span class="bash">2.通过blob id查询大文件的文件名</span></span><br><span class="line">git rev-list --objects --all | grep blobid </span><br><span class="line"><span class="meta">#</span><span class="bash">3.查看该文件的所有提交记录</span></span><br><span class="line">git log --branches -- zz/xx.zip 或</span><br><span class="line">git log --pretty=oneline --branches -- zz/xx.zip</span><br><span class="line"><span class="meta">#</span><span class="bash">4.将该文件从历史记录的所有tree中移除,并用filter-branch命令重写所有commit才能将该文件从git历史中完全移除</span></span><br><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch zz/xx.zip&#x27; --prune-empty --tag-name-filter cat -- --all</span><br><span class="line"><span class="meta">#</span><span class="bash">5.依次执行以下命令,清理和回收空间</span></span><br><span class="line">rm -rf .git/refs/original/</span><br><span class="line">rm -rf .git/logs/</span><br><span class="line">git gc</span><br><span class="line">gir prune</span><br><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure>

<h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>打开本地git bash,使用如下命令生成ssh公钥和私钥对</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;` # 然后一路回车(-C 参数是你的邮箱地址)</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开~/.ssh/id_rsa.pub文件(~表示用户目录)，复制其中的内容</span><br><span class="line">打开gitlab,找到Profile Settings--&gt;SSH Keys---&gt;Add SSH Key,并把上一步中复制的内容粘贴到Key所对应的文本框，在Title对应的文本框中给这个sshkey设置一个名字，点击Add key按钮</span><br><span class="line">到此就完成了gitlab配置ssh key的所有步骤，可以使用ssh协议不需要输入密码进行代码的拉取以及提交等操作了</span><br></pre></td></tr></table></figure>

<h4 id="本地配置多个ssh-key"><a href="#本地配置多个ssh-key" class="headerlink" title="本地配置多个ssh key"></a>本地配置多个ssh key</h4><p>大多数时候，我们的机器上会有很多的git host,比如公司gitlab、github、oschina等，那我们就需要在本地配置多个ssh key，使得不同的host能使用不同的ssh key ,做法如下（以公司gitlab和github为例）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为公司生成一对秘钥ssh key</span></span><br><span class="line">ssh-keygen -t rsa -C &#x27;yourEmail@xx.com&#x27; -f ~/.ssh/gitlab-rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为github生成一对秘钥ssh key</span></span><br><span class="line">ssh-keygen -t rsa -C &#x27;yourEmail2@xx.com&#x27; -f ~/.ssh/github-rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在~/.ssh目录下新建名称为config的文件（无后缀名）。用于配置多个不同的host使用不同的ssh key，内容如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/gitlab_id-rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github_id-rsa</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HostName : 要登录主机的主机名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> User : 登录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IdentityFile : 指明上面User对应的identityFile路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照上面的步骤分别往gitlab和github上添加生成的公钥gitlab_id-rsa.pub和github_id-rsa.pub</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OK，大功告成，再次执行git命令验证是不是已经不需要再次验证权限了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看~/..ssh目录下的文件,会有gitlab_id-rsa、gitlab_id-rsa.pub和github_id-rsa、github_id-rsa.pub四个文件</span></span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/bq/efdd0a04.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/ab9e1965.html">git基本操作</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-04</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">代码管理</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/git/">git</a></div></div><div class="post-content"><div class="main-content content"><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前配置：</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以当前目录为基础创建本地仓库：</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加暂存区：.所有修改新增文件 -u所有修改删除 -A所有</span></span><br><span class="line">git add xxx文件 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看暂存区倌息：</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区提交历史区：</span></span><br><span class="line">git commit -m‘说明’</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一并提交暂存区历史区（只适合已提交过文件）：</span></span><br><span class="line">git commit -a -m‘说明’</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支：</span></span><br><span class="line">git branch</span><br><span class="line">.gitignore文件，提交忽略项如.idea和node_modules等</span><br><span class="line"><span class="meta">#</span><span class="bash"> 历史记录：</span></span><br><span class="line">git log /reflog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区所有内容撤回工作区所有记录，少用：</span></span><br><span class="line">git rm -cached . r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区撤回工作区,覆盖工作区不可恢复：</span></span><br><span class="line">git checkout .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区回滚到上一次:</span></span><br><span class="line">git reset HEAD .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区VS暂存区：</span></span><br><span class="line">git diff</span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区VS历史区：</span></span><br><span class="line">git diff master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区VS历史区：</span></span><br><span class="line">git diff -cached</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回滚历史版本暂存区工作区都被替代：</span></span><br><span class="line">git reset --hard 版本号</span><br><span class="line">history》history.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关联远程仓库：</span></span><br><span class="line">git remote add 名字(oringin) 远程仓库地址</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除：</span></span><br><span class="line">git remote rm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看：</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化：</span></span><br><span class="line">git clone 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 历史区同步</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到远程仓库：</span></span><br><span class="line">git push oringin master </span><br><span class="line"><span class="meta">#</span><span class="bash"> 从远程仓库拉取：</span></span><br><span class="line">git pull oringin master </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独分支管理：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建分支</span></span><br><span class="line">git branch xxx </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line">git checkout xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建分支并切换</span></span><br><span class="line">git checkout -b xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line">git branch -D xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并分支</span></span><br><span class="line">git merge xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支提交和合并内容</span></span><br><span class="line">git log --graph / --oneline</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取当前分支名</span></span><br><span class="line">git symbolic-ref --short -q HEAD</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于历史commit创建分支</span></span><br><span class="line">git checkout -b branchname 92483401abdc41bc64bbdde1a63ed7bbee403e19</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地分支push到远程服务器，远程分支与本地分支同名(当然可以随意起名)</span></span><br><span class="line">git push origin branchname:branchname</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git push origin --delete branchname</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送一个空分支到远程分支，其实就相当于删除远程分支</span></span><br><span class="line">git push origin :branchname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从仓库同步</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span><span class="bash"> 历史坂本：</span></span><br><span class="line">git reset版本号</span><br><span class="line">git checkout文件名 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制覆盖本地</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置关联远程</span></span><br><span class="line">git config remote.origin.url git@github.com:your_username/your_project.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> https方式每次都要输入密码，按照如下设置即可输入一次就不用再手输入密码的困扰而且又享受https带来的极速</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置记住密码（默认15分钟）：</span></span><br><span class="line">git config --global credential.helper cache</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义设置时间：（设置一个小时之后失效）</span></span><br><span class="line">git config credential.helper &#x27;cache --timeout=3600&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 长期存储密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加远程地址的时候带上密码也是可以的。(推荐)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用客户端也可以存储密码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换ssh-&gt;https</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到项目目录下 ：</span></span><br><span class="line">cd projectfile/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除远程ssh方式的仓库地址</span></span><br><span class="line">git remote rm origin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加https远程仓库地址</span></span><br><span class="line">git remote add origin http://yourname:password@git.oschina.net/name/project.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git config 查看配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">config 配置有system级别 global（用户级别） 和<span class="built_in">local</span>（当前仓库）三个 设置先从system-》global-》<span class="built_in">local</span>  底层配置会覆盖顶层配置 分别使用--system/global/<span class="built_in">local</span> 可以定位到配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前仓库配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git config -- <span class="built_in">local</span>    --list</span></span><br><span class="line"></span><br><span class="line">git branch #查看本地所有分支</span><br><span class="line">git status #查看当前状态 </span><br><span class="line">git commit #提交 </span><br><span class="line">git branch -a #查看所有的分支</span><br><span class="line">git branch -r #查看远程所有分支</span><br><span class="line">git commit -am &quot;init&quot; #提交并且加注释 </span><br><span class="line">git remote add origin git@192.168.1.119:ndshow</span><br><span class="line">git push origin master 将文件给推到服务器上 </span><br><span class="line">git remote show origin 显示远程库origin里的资源 </span><br><span class="line">git push origin master:develop</span><br><span class="line">git push origin master:hb-dev #将本地库与服务器上的库进行关联 </span><br><span class="line">git checkout --track origin/dev #切换到远程dev分支</span><br><span class="line">git branch -D master develop #删除本地库develop</span><br><span class="line">git checkout -b dev #建立一个新的本地分支dev</span><br><span class="line">git merge origin/dev #将分支dev与当前分支进行合并</span><br><span class="line">git checkout dev #切换到本地dev分支</span><br><span class="line">git remote show #查看远程库</span><br><span class="line">git add .</span><br><span class="line">git rm 文件名(包括路径) #从git中删除指定文件</span><br><span class="line">git clone git://github.com/schacon/grit.git #从服务器上将代码给拉下来</span><br><span class="line">git config --list #看所有用户</span><br><span class="line">git ls-files #看已经被提交的</span><br><span class="line">git rm [file name] #删除一个文件</span><br><span class="line">git commit -a #提交当前repos的所有的改变</span><br><span class="line">git add [file name] #添加一个文件到git index</span><br><span class="line">git commit -v #当你用－v参数的时候可以看commit的差异</span><br><span class="line">git commit -m &quot;This is the message describing the commit&quot; #添加commit信息</span><br><span class="line">git commit -a -a #是代表add，把所有的change加到git index里然后再commit</span><br><span class="line">git commit -a -v #一般提交命令</span><br><span class="line">git log #看你commit的日志</span><br><span class="line">git diff #查看尚未暂存的更新</span><br><span class="line">git rm a.a #移除文件(从暂存区和工作区中删除)</span><br><span class="line">git rm --cached a.a #移除文件(只从暂存区中删除)</span><br><span class="line">git commit -m &quot;remove&quot; #移除文件(从Git中删除)</span><br><span class="line">git rm -f a.a #强行移除修改后文件(从暂存区和工作区中删除)</span><br><span class="line">git diff --cached 或 $ git diff --staged #查看尚未提交的更新</span><br><span class="line">git stash push #将文件给push到一个临时空间中</span><br><span class="line">git stash pop #将文件从临时空间pop下来</span><br><span class="line">\---------------------------------------------------------</span><br><span class="line">git remote add origin git@github.com:username/Hello-World.git</span><br><span class="line">git push origin master #将本地项目给提交到服务器中</span><br><span class="line">\-----------------------------------------------------------</span><br><span class="line">git pull #本地与服务器端同步</span><br><span class="line">\-----------------------------------------------------------------</span><br><span class="line">git push (远程仓库名) (分支名) #将本地分支推送到服务器上去。</span><br><span class="line">git push origin serverfix:awesomebranch</span><br><span class="line">\------------------------------------------------------------------</span><br><span class="line">git fetch #相当于是从远程获取最新版本到本地，不会自动merge</span><br><span class="line">git commit -a -m &quot;log_message&quot; #(-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</span><br><span class="line">git branch branch_0.1 master #从主分支master创建branch_0.1分支</span><br><span class="line">git branch -m branch_0.1 branch_1.0 #将branch_0.1重命名为branch_1.0</span><br><span class="line">git checkout branch_1.0/master #切换到branch_1.0/master分支</span><br><span class="line">git branch </span><br><span class="line">git push origin :branch_remote_name</span><br><span class="line">git branch -r -d branch_remote_name #删除远程branch</span><br><span class="line">\-----------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化版本库，并提交到远程服务器端</span></span><br><span class="line">mkdir WebApp</span><br><span class="line">cd WebApp</span><br><span class="line">git init #本地初始化</span><br><span class="line">touch README</span><br><span class="line">git add README #添加文件</span><br><span class="line">git commit -m &#x27;first commit&#x27;</span><br><span class="line">git remote add origin git@github.com:username/Hello-World.git #增加一个远程服务器端</span><br><span class="line"><span class="meta">#</span><span class="bash">上面的命令会增加URL地址为<span class="string">&#x27;git@github.com:username/Hello-World.git&#x27;</span>，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可</span></span><br></pre></td></tr></table></figure>

<h3 id="命令速查表"><a href="#命令速查表" class="headerlink" title="命令速查表"></a>命令速查表</h3><h4 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加至暂存区</td>
</tr>
<tr>
<td>git add–interactive</td>
<td>交互式添加</td>
</tr>
<tr>
<td>git apply</td>
<td>应用补丁</td>
</tr>
<tr>
<td>git am</td>
<td>应用邮件格式补丁</td>
</tr>
<tr>
<td>git annotate</td>
<td>同义词，等同于 git blame</td>
</tr>
<tr>
<td>git archive</td>
<td>文件归档打包</td>
</tr>
<tr>
<td>git bisect</td>
<td>二分查找</td>
</tr>
<tr>
<td>git blame</td>
<td>文件逐行追溯</td>
</tr>
<tr>
<td>git branch</td>
<td>分支管理</td>
</tr>
<tr>
<td>git cat-file</td>
<td>版本库对象研究工具</td>
</tr>
<tr>
<td>git checkout</td>
<td>检出到工作区、切换或创建分支</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>提交拣选</td>
</tr>
<tr>
<td>git citool</td>
<td>图形化提交，相当于 git gui 命令</td>
</tr>
<tr>
<td>git clean</td>
<td>清除工作区未跟踪文件</td>
</tr>
<tr>
<td>git clone</td>
<td>克隆版本库</td>
</tr>
<tr>
<td>git commit</td>
<td>提交</td>
</tr>
<tr>
<td>git config</td>
<td>查询和修改配置</td>
</tr>
<tr>
<td>git describe</td>
<td>通过里程碑直观地显示提交ID</td>
</tr>
<tr>
<td>git diff</td>
<td>差异比较</td>
</tr>
<tr>
<td>git difftool</td>
<td>调用图形化差异比较工具</td>
</tr>
<tr>
<td>git fetch</td>
<td>获取远程版本库的提交</td>
</tr>
<tr>
<td>git format-patch</td>
<td>创建邮件格式的补丁文件。参见 git am 命令</td>
</tr>
<tr>
<td>git grep</td>
<td>文件内容搜索定位工具</td>
</tr>
<tr>
<td>git gui</td>
<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>
</tr>
<tr>
<td>git help</td>
<td>帮助</td>
</tr>
<tr>
<td>git init</td>
<td>版本库初始化</td>
</tr>
<tr>
<td>git init-db*</td>
<td>同义词，等同于 git init</td>
</tr>
<tr>
<td>git log</td>
<td>显示提交日志</td>
</tr>
<tr>
<td>git merge</td>
<td>分支合并</td>
</tr>
<tr>
<td>git mergetool</td>
<td>图形化冲突解决</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名</td>
</tr>
<tr>
<td>git pull</td>
<td>拉回远程版本库的提交</td>
</tr>
<tr>
<td>git push</td>
<td>推送至远程版本库</td>
</tr>
<tr>
<td>git rebase</td>
<td>分支变基</td>
</tr>
<tr>
<td>git rebase–interactive</td>
<td>交互式分支变基</td>
</tr>
<tr>
<td>git reflog</td>
<td>分支等引用变更记录管理</td>
</tr>
<tr>
<td>git remote</td>
<td>远程版本库管理</td>
</tr>
<tr>
<td>git repo-config*</td>
<td>同义词，等同于 git config</td>
</tr>
<tr>
<td>git reset</td>
<td>重置改变分支“游标”指向</td>
</tr>
<tr>
<td>git rev-parse</td>
<td>将各种引用表示法转换为哈希值等</td>
</tr>
<tr>
<td>git revert</td>
<td>反转提交</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git show</td>
<td>显示各种类型的对象</td>
</tr>
<tr>
<td>git stage*</td>
<td>同义词，等同于 git add</td>
</tr>
<tr>
<td>git stash</td>
<td>保存和恢复进度</td>
</tr>
<tr>
<td>git status</td>
<td>显示工作区文件状态</td>
</tr>
<tr>
<td>git tag</td>
<td>里程碑管理</td>
</tr>
</tbody></table>
<h4 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git commit-tree</td>
<td>从树对象创建提交</td>
</tr>
<tr>
<td>git hash-object</td>
<td>从标准输入或文件计算哈希值或创建对象</td>
</tr>
<tr>
<td>git ls-files</td>
<td>显示工作区和暂存区文件</td>
</tr>
<tr>
<td>git ls-tree</td>
<td>显示树对象包含的文件</td>
</tr>
<tr>
<td>git mktag</td>
<td>读取标准输入创建一个里程碑对象</td>
</tr>
<tr>
<td>git mktree</td>
<td>读取标准输入创建一个树对象</td>
</tr>
<tr>
<td>git read-tree</td>
<td>读取树对象到暂存区</td>
</tr>
<tr>
<td>git update-index</td>
<td>工作区内容注册到暂存区及暂存区管理</td>
</tr>
<tr>
<td>git unpack-file</td>
<td>创建临时文件包含指定 blob 的内容</td>
</tr>
<tr>
<td>git write-tree</td>
<td>从暂存区创建一个树对象</td>
</tr>
</tbody></table>
<h4 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git check-ref-format</td>
<td>检查引用名称是否符合规范</td>
</tr>
<tr>
<td>git for-each-ref</td>
<td>引用迭代器，用于shell编程</td>
</tr>
<tr>
<td>git ls-remote</td>
<td>显示远程版本库的引用</td>
</tr>
<tr>
<td>git name-rev</td>
<td>将提交ID显示为友好名称</td>
</tr>
<tr>
<td>git peek-remote*</td>
<td>过时命令，请使用 git ls-remote</td>
</tr>
<tr>
<td>git rev-list</td>
<td>显示版本范围</td>
</tr>
<tr>
<td>git show-branch</td>
<td>显示分支列表及拓扑关系</td>
</tr>
<tr>
<td>git show-ref</td>
<td>显示本地引用</td>
</tr>
<tr>
<td>git symbolic-ref</td>
<td>显示或者设置符号引用</td>
</tr>
<tr>
<td>git update-ref</td>
<td>更新引用的指向</td>
</tr>
<tr>
<td>git verify-tag</td>
<td>校验 GPG 签名的Tag</td>
</tr>
</tbody></table>
<h4 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git count-objects</td>
<td>显示松散对象的数量和磁盘占用</td>
</tr>
<tr>
<td>git filter-branch</td>
<td>版本库重构</td>
</tr>
<tr>
<td>git fsck</td>
<td>对象库完整性检查</td>
</tr>
<tr>
<td>git fsck-objects*</td>
<td>同义词，等同于 git fsck</td>
</tr>
<tr>
<td>git gc</td>
<td>版本库存储优化</td>
</tr>
<tr>
<td>git index-pack</td>
<td>从打包文件创建对应的索引文件</td>
</tr>
<tr>
<td>git lost-found*</td>
<td>过时，请使用 git fsck –lost-found 命令</td>
</tr>
<tr>
<td>git pack-objects</td>
<td>从标准输入读入对象ID，打包到文件</td>
</tr>
<tr>
<td>git pack-redundant</td>
<td>查找多余的 pack 文件</td>
</tr>
<tr>
<td>git pack-refs</td>
<td>将引用打包到 .git/packed-refs 文件中</td>
</tr>
<tr>
<td>git prune</td>
<td>从对象库删除过期对象</td>
</tr>
<tr>
<td>git prune-packed</td>
<td>将已经打包的松散对象删除</td>
</tr>
<tr>
<td>git relink</td>
<td>为本地版本库中相同的对象建立硬连接</td>
</tr>
<tr>
<td>git repack</td>
<td>将版本库未打包的松散对象打包</td>
</tr>
<tr>
<td>git show-index</td>
<td>读取包的索引文件，显示打包文件中的内容</td>
</tr>
<tr>
<td>git unpack-objects</td>
<td>从打包文件释放文件</td>
</tr>
<tr>
<td>git verify-pack</td>
<td>校验对象库打包文件</td>
</tr>
</tbody></table>
<h4 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch-pack</td>
<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>
</tr>
<tr>
<td>git receive-pack</td>
<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>
</tr>
<tr>
<td>git send-pack</td>
<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>
</tr>
<tr>
<td>git upload-archive</td>
<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>
</tr>
<tr>
<td>git upload-pack</td>
<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>
</tr>
</tbody></table>
<h4 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git imap-send</td>
<td>将补丁通过 IMAP 发送</td>
</tr>
<tr>
<td>git mailinfo</td>
<td>从邮件导出提交说明和补丁</td>
</tr>
<tr>
<td>git mailsplit</td>
<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>
</tr>
<tr>
<td>git request-pull</td>
<td>创建包含提交间差异和执行PULL操作地址的信息</td>
</tr>
<tr>
<td>git send-email</td>
<td>发送邮件</td>
</tr>
</tbody></table>
<h4 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git daemon</td>
<td>实现Git协议</td>
</tr>
<tr>
<td>git http-backend</td>
<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>
</tr>
<tr>
<td>git instaweb</td>
<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>
</tr>
<tr>
<td>git shell</td>
<td>受限制的shell，提供仅执行Git命令的SSH访问</td>
</tr>
<tr>
<td>git update-server-info</td>
<td>更新哑协议需要的辅助文件</td>
</tr>
<tr>
<td>git http-fetch</td>
<td>通过HTTP协议获取版本库</td>
</tr>
<tr>
<td>git http-push</td>
<td>通过HTTP/DAV协议推送</td>
</tr>
<tr>
<td>git remote-ext</td>
<td>由Git命令调用，通过外部命令提供扩展协议支持</td>
</tr>
<tr>
<td>git remote-fd</td>
<td>由Git命令调用，使用文件描述符作为协议接口</td>
</tr>
<tr>
<td>git remote-ftp</td>
<td>由Git命令调用，提供对FTP协议的支持</td>
</tr>
<tr>
<td>git remote-ftps</td>
<td>由Git命令调用，提供对FTPS协议的支持</td>
</tr>
<tr>
<td>git remote-http</td>
<td>由Git命令调用，提供对HTTP协议的支持</td>
</tr>
<tr>
<td>git remote-https</td>
<td>由Git命令调用，提供对HTTPS协议的支持</td>
</tr>
<tr>
<td>git remote-testgit</td>
<td>协议扩展示例脚本</td>
</tr>
</tbody></table>
<h4 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git archimport</td>
<td>导入Arch版本库到Git</td>
</tr>
<tr>
<td>git bundle</td>
<td>提交打包和解包，以便在不同版本库间传递</td>
</tr>
<tr>
<td>git cvsexportcommit</td>
<td>将Git的一个提交作为一个CVS检出</td>
</tr>
<tr>
<td>git cvsimport</td>
<td>导入CVS版本库到Git。或者使用 cvs2git</td>
</tr>
<tr>
<td>git cvsserver</td>
<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>
</tr>
<tr>
<td>git fast-export</td>
<td>将提交导出为 git-fast-import 格式</td>
</tr>
<tr>
<td>git fast-import</td>
<td>其他版本库迁移至Git的通用工具</td>
</tr>
<tr>
<td>git svn</td>
<td>Git 作为前端操作 Subversion</td>
</tr>
</tbody></table>
<h4 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git merge-base</td>
<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>
</tr>
<tr>
<td>git merge-file</td>
<td>针对文件的两个不同版本执行三向文件合并</td>
</tr>
<tr>
<td>git merge-index</td>
<td>对index中的冲突文件调用指定的冲突解决工具</td>
</tr>
<tr>
<td>git merge-octopus</td>
<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>
</tr>
<tr>
<td>git merge-one-file</td>
<td>由 git merge-index 调用的标准辅助程序</td>
</tr>
<tr>
<td>git merge-ours</td>
<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>
</tr>
<tr>
<td>git merge-recursive</td>
<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>
</tr>
<tr>
<td>git merge-resolve</td>
<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>
</tr>
<tr>
<td>git merge-subtree</td>
<td>子树合并。参见 git merge 的 subtree 合并策略</td>
</tr>
<tr>
<td>git merge-tree</td>
<td>显式三向合并结果，不改变暂存区</td>
</tr>
<tr>
<td>git fmt-merge-msg</td>
<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>
</tr>
<tr>
<td>git rerere</td>
<td>重用所记录的冲突解决方案</td>
</tr>
</tbody></table>
<h4 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h4><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git bisect–helper</td>
<td>由 git bisect 命令调用，确认二分查找进度</td>
</tr>
<tr>
<td>git check-attr</td>
<td>显示某个文件是否设置了某个属性</td>
</tr>
<tr>
<td>git checkout-index</td>
<td>从暂存区拷贝文件至工作区</td>
</tr>
<tr>
<td>git cherry</td>
<td>查找没有合并到上游的提交</td>
</tr>
<tr>
<td>git diff-files</td>
<td>比较暂存区和工作区，相当于 git diff –raw</td>
</tr>
<tr>
<td>git diff-index</td>
<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>
</tr>
<tr>
<td>git diff-tree</td>
<td>比较两个树对象，相当于 git diff –raw A B</td>
</tr>
<tr>
<td>git difftool–helper</td>
<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>
</tr>
<tr>
<td>git get-tar-commit-id</td>
<td>从 git archive 创建的 tar 包中提取提交ID</td>
</tr>
<tr>
<td>git gui–askpass</td>
<td>命令 git gui 的获取用户口令输入界面</td>
</tr>
<tr>
<td>git notes</td>
<td>提交评论管理</td>
</tr>
<tr>
<td>git patch-id</td>
<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>
</tr>
<tr>
<td>git quiltimport</td>
<td>将Quilt补丁列表应用到当前分支</td>
</tr>
<tr>
<td>git replace</td>
<td>提交替换</td>
</tr>
<tr>
<td>git shortlog</td>
<td>对 git log 的汇总输出，适合于产品发布说明</td>
</tr>
<tr>
<td>git stripspace</td>
<td>删除空行，供其他脚本调用</td>
</tr>
<tr>
<td>git submodule</td>
<td>子模组管理</td>
</tr>
<tr>
<td>git tar-tree</td>
<td>过时命令，请使用 git archive</td>
</tr>
<tr>
<td>git var</td>
<td>显示 Git 环境变量</td>
</tr>
<tr>
<td>git web–browse</td>
<td>启动浏览器以查看目录或文件</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>显示提交历史及每次提交的改动</td>
</tr>
<tr>
<td>git-mergetool–lib</td>
<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>
</tr>
<tr>
<td>git-parse-remote</td>
<td>包含于其他脚本中，提供操作远程版本库的函数</td>
</tr>
<tr>
<td>git-sh-setup</td>
<td>包含于其他脚本中，提供 shell 编程的函数库</td>
</tr>
</tbody></table>
<h3 id="设置代理访问git"><a href="#设置代理访问git" class="headerlink" title="设置代理访问git"></a>设置代理访问git</h3><p>Git允许使用三种协议来连接远程仓库：ssh、http、git。所以，如果你要设置代理，必须首先明确本地git使用何种协议连接远程仓库，然后根据不同协议设置代理。<br><strong>前提</strong>：socks5代理服务器，默认端口1080</p>
<h4 id="设置SSH协议的代理"><a href="#设置SSH协议的代理" class="headerlink" title="设置SSH协议的代理"></a>设置SSH协议的代理</h4><p>如果远程仓库拥有如下的格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git@github.com:guobq/guobq.github.io.git</span><br><span class="line">ssh://git@github.com:guobq/guobq.github.io.git</span><br></pre></td></tr></table></figure>
<p>说明是使用SSH协议连接的远程仓库。git依赖ssh去连接，需要配置ssh的socks5代理实现git的代理。在ssh的配置文件~/.ssh/config（没有则新建）使用ProxyCommand配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Linux</span></span><br><span class="line">Host bitbucket.org</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname bitbucket.org</span><br><span class="line">  ProxyCommand nc -x 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">windows</span></span><br><span class="line">Host bitbucket.org</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname bitbucket.org</span><br><span class="line">  ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>
<p>如果使用github，只需要把bitbucket.org换成github.com。<br>具体配置的含义请参考:<a target="_blank" rel="noopener" href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/ssh_config.5?query=ssh_config&amp;sec=5&amp;arch=amd64%E3%80%82">http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/ssh_config.5?query=ssh_config&amp;sec=5&amp;arch=amd64。</a></p>
<h4 id="设置http-https协议代理"><a href="#设置http-https协议代理" class="headerlink" title="设置http/https协议代理"></a>设置http/https协议代理</h4><p>如果远程仓库链接拥有如下格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://github.com/guobq/guobq.github.io.git</span><br><span class="line">https://github.com/guobq/guobq.github.io.git</span><br></pre></td></tr></table></figure>
<p>说明使用的是http/https协议，可以使用git配套的CMSSW支持的代理协议：SOCKS4、SOCKS5和HTTPS/HTTPS。可通过配置http.proxy实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">全局设置</span></span><br><span class="line">git config --global http.proxy socks5://localhost:1080</span><br><span class="line"><span class="meta">#</span><span class="bash">本次设置</span></span><br><span class="line">git clone https://github.com/guobq/guobq.github.io.git --config &quot;http.proxy=127.0.0.1:1080&quot;</span><br></pre></td></tr></table></figure>
<p>这里演示的是socks5的配置，需要其他配置的可参考git-config配置中的http.proxy。</p>
<h4 id="设置Git协议的代理"><a href="#设置Git协议的代理" class="headerlink" title="设置Git协议的代理"></a>设置Git协议的代理</h4><p>Git协议是Git提供的一个守护进程，它监听专门的端口（9418），然后提供类似于ssh协议一样的服务，只是它不需要验证。所以，然后用户通过网络都可以使用git协议连接提供git连接的仓库。<br>如果远程仓库的链接是如下形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git://github.com/archerie/learngit.git</span><br></pre></td></tr></table></figure>
<p>该仓库使用git协议连接。需要使用CMSSW提供的简单脚本去通过socks5代理访问：git-proxy。配置如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.gitproxy &quot;git-proxy&quot;</span><br><span class="line">git config --global socks.proxy &quot;localhost:1080&quot;</span><br></pre></td></tr></table></figure>

<h3 id="questions"><a href="#questions" class="headerlink" title="questions"></a>questions</h3><p>Git Pull Failed:You have not concluded your merge.Exiting because of unfinished merge</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在拉取远程代码时，出现这样的情况，Git Pull Failed:You have not concluded your merge.Exiting because of unfinished merge。出现这种情况的原因如系统提示，可能在pull代码之前merge合并失败。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在解决这个问题之前，先看看需要了解的知识。</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="meta">#</span><span class="bash">用于从另一个存储库下载对象和引用。远程跟踪已更新分支（git术语叫commit），需要将这些更新取回本地，这时就要用到git fetch命令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">语法：git fetch &lt;远程主机名&gt;。例如：git fetch orgin master，表示取回origin主机的master分支。更新所有分支，命令可以简写为git fetch。</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span><span class="bash">用于取回远程主机某个分支的更新，再与本地的指定分支合并。这时你可能已经真正明白为什么会出现拉取失败的原因了，原因就在于拉取之后的代码合并失败造成的。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">语法：git pull &lt;远程主机名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;。例如：git pull origin next:master，表示取回origin主机的next分支，与本地的master分支合并。如果远程分支（next）要与当前分支合并，则冒号后面的部分可以省略。</span></span><br><span class="line">git reset</span><br><span class="line"><span class="meta">#</span><span class="bash">语法：git reset [- -hard|soft|mixed|merge|keep][或HEAD]，将当前的分支重新设置到指定的commit id或者HEAD，其中HEAD是默认路径。其中hard、soft、mixed、merge、keep是设置的模式。通常使用- -hard，表示自commit id以来，工作目录中的任何改变都被丢弃，并把HEAD指向commit id。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解决方法</span></span><br><span class="line"><span class="meta">#</span><span class="bash">方法一：舍弃本地代码，远程版本覆盖本地版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用这种方法之前，可以先将本地修改的代码备份一下，避免重敲代码。具体命令如下：</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">方法二：保留本地代码，中止合并–&gt;重新合并–&gt;重新拉取</span></span><br><span class="line">git merge --abort</span><br><span class="line">git reset --merge</span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span><span class="bash">这种做法需要处理代码冲突，因此以上两种做法，根据你的需要，选择合适的解决办法。</span></span><br></pre></td></tr></table></figure>









</div></div><a class="button-hover more" href="/bq/ab9e1965.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/5a003532.html">需求管理成熟度</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-04-11</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E4%BD%93%E7%B3%BB/">体系</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E4%BD%93%E7%B3%BB/%E8%BF%87%E7%A8%8B%E8%B4%A8%E9%87%8F/">过程质量</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86/">需求管理</a></div></div><div class="post-content"><div class="main-content content"><h3 id="需求管理成熟度"><a href="#需求管理成熟度" class="headerlink" title="需求管理成熟度"></a>需求管理成熟度</h3><h5 id="级别一：被记录的需求（Written-Requirements）"><a href="#级别一：被记录的需求（Written-Requirements）" class="headerlink" title="级别一：被记录的需求（Written Requirements）"></a>级别一：被记录的需求（Written Requirements）</h5><p>简单的写出需求。好处：</p>
<p>与客户有一个基本的约定。如果写的好，需求能够清晰地描述你对客户需要的理解，他们可以通过阅读需求来检查是否与他们想的一致</p>
<p>开发团队的每个成员通过需求可以很好的支持他们的工作。架构师和设计师可以开始考虑如何架构系统来支持客户期望，也可以支持测试人员及早开始测试案例的编写，当然更能支持开发人员理解软件要求来编写代码</p>
<p>需求可以让新来的成员更快速的了解系统是什么</p>
<p>成本：</p>
<p>需要有人花时间来写需求</p>
<p>为了保证需求的及时性，需要不断地维护需求</p>
<h5 id="级别二：被组织的需求（Organized）"><a href="#级别二：被组织的需求（Organized）" class="headerlink" title="级别二：被组织的需求（Organized）"></a>级别二：被组织的需求（Organized）</h5><p>需求的目的是为了清晰地与用户、客户和其他涉众（例如开发团队）等人就问题的解决方案进行沟通。级别二关注需求质量、格式化、安全和存储，以及版本管理。</p>
<p>质量：好的需求容易让大家明白，架构师、开发人员和测试人员也都能很好的使用它，不好的需求会导致大家比较模糊、认识存在差异等问题。</p>
<p>格式化：需求必须以统一的方式来描述，例如序号、标题、字体、表格等，可以使得文档更容易阅读、理解和使用，文档模板可以帮助我们以统一格式来编制</p>
<p>访问性、安全性和版本管理：当存在很多需求时，我们会经常遇到不知道在哪里可以找到需要的需求，这时我们就需要有一个统一管理需求地方</p>
<h5 id="级别三：结构化需求（Structured）"><a href="#级别三：结构化需求（Structured）" class="headerlink" title="级别三：结构化需求（Structured）"></a>级别三：结构化需求（Structured）</h5><p>对需求进行归类，它们是功能性需求还是非功能性需求？是业务需求还是系统需求？是特性还是软件需求？客户、市场和用户需求是什么？区分这些可以帮助我们更好的理解和管理需求。之前级别都是用一些文字类语言来描述，而级别三是一种结构化需求，例如给需求添加一些属性。</p>
<h5 id="级别四：可跟踪性需求（Traced）"><a href="#级别四：可跟踪性需求（Traced）" class="headerlink" title="级别四：可跟踪性需求（Traced）"></a>级别四：可跟踪性需求（Traced）</h5><p>需求本身就是层级的，由业务需求到用户需求再到系统需求；而需求又与开发和测试有所关联，通过可跟踪性管理，我们可以知道在更改一个需求时，会影响到哪些子需求以及相关的同级需求，还能够分析出影响哪些开发和测试内容。</p>
<h5 id="级别五：集成化需求（Integrated）"><a href="#级别五：集成化需求（Integrated）" class="headerlink" title="级别五：集成化需求（Integrated）"></a>级别五：集成化需求（Integrated）</h5><p>通常我们做了很多需求，但是并没有一种集成化的方法把需求直接引入开发中，可能导致实现出来的是另一回事。集成化需求管理流程可以直接由需求导入软件设计、变更管理、测试和项目管理。团队将需求作为主要输入，如果将需求模型化，我们则可以通过模型化需求来开发应用程序，目标就是要做成能够让业务工程师来开发应用程序。</p>
</div></div><a class="button-hover more" href="/bq/5a003532.html#more">阅读全文</a></div><div class="recent-post-item"><i class="article-top"></i><a class="post-title" href="/bq/d22f4620.html">cmmi效能</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-04-11</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E4%BD%93%E7%B3%BB/">体系</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E4%BD%93%E7%B3%BB/%E6%95%88%E8%83%BD/">效能</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cmmi/">cmmi</a></div></div><div class="post-content"><div class="main-content content"><h2 id="效能与质量"><a href="#效能与质量" class="headerlink" title="效能与质量"></a>效能与质量</h2><h3 id="研发阶段和效率价值金字塔"><a href="#研发阶段和效率价值金字塔" class="headerlink" title="研发阶段和效率价值金字塔"></a>研发阶段和效率价值金字塔</h3><blockquote>
<p>需求调研和评审&gt;技术方案设计和评审&gt;研发&gt;测试</p>
</blockquote>
<h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><h4 id="CMMI级别中和BUG率相关的信息"><a href="#CMMI级别中和BUG率相关的信息" class="headerlink" title="CMMI级别中和BUG率相关的信息"></a>CMMI级别中和BUG率相关的信息</h4><table>
<thead>
<tr>
<th>CMMI级别</th>
<th>BUG率</th>
</tr>
</thead>
<tbody><tr>
<td>CMM1级</td>
<td>11.95‰</td>
</tr>
<tr>
<td>CMM2级</td>
<td>5.52‰</td>
</tr>
<tr>
<td>CMM3级</td>
<td>2.39‰</td>
</tr>
<tr>
<td>CMM4级</td>
<td>0.92‰</td>
</tr>
<tr>
<td>CMM5级</td>
<td>0.32‰</td>
</tr>
</tbody></table>
<h4 id="考核千行代码Bug率的问题"><a href="#考核千行代码Bug率的问题" class="headerlink" title="考核千行代码Bug率的问题"></a>考核千行代码Bug率的问题</h4><blockquote>
<p>代码行数&lt;&gt;价值</p>
</blockquote>
<p>考核标准：Bug率数值越小就说明越好-&gt;尽量增大代码行数</p>
<p>考核阶段：Bug率的数据主要产出在研发阶段的后期，及提交测试后产出bug数-&gt;从项目的研发阶段和效率价值金字塔来看，其对项目的整体质量方面更多的聚焦在微观层面问题，整体的质量的影响范围会较小。</p>
<h4 id="更合理的度量质量"><a href="#更合理的度量质量" class="headerlink" title="更合理的度量质量"></a>更合理的度量质量</h4><ol>
<li><p>需求的评审</p>
</li>
<li><p>架构设计方案评审</p>
</li>
<li><p>代码模块设计，包的依赖的规划，接口的设计的review</p>
</li>
<li><p>代码的review的机制</p>
</li>
<li><p>测试用例评审</p>
</li>
<li><p>使用代码检测工具，自动发现问题</p>
</li>
</ol>
<blockquote>
<p>过程评审是最有效也是成本最低的质量和效率保证和提升的手段。另外，过程评审还是迅速提高新人能力及其成果物的规范性的一个有效手段。</p>
</blockquote>
<h5 id="系统质量是要靠上游工程做出来的"><a href="#系统质量是要靠上游工程做出来的" class="headerlink" title="系统质量是要靠上游工程做出来的"></a>系统质量是要靠上游工程做出来的</h5><p>上游的工作质量会更为重要，上游的问题的影响范围将更广，对效率和价值的影响更大，应该是我们重点关注的地方。仅仅依赖下游工程(种种测试)来把质量关，是十分低效，而且代价是非常昂贵的。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><blockquote>
<p>1.需求要被管理，被管理的意思又有两层：一是需求要被确认，二是要控制需求变更</p>
<p>2.需求要用来指导下游的工作产品，如：计划、设计、测试等</p>
</blockquote>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote>
<p>1.因为项目进度赶等原因，在很多需求还没有明确情况下，便开始开发的工作。<br>2.开始客户只能提出模糊的需求，客户喜欢先让你做个东西给他看，然后他才可能逐渐提出真正的需求，而需求调研人员，对此没有什么好的处理办法。<br>3.客户以种种原因不签需求，项目组在不签需求的情况下，便开始开发工作。<br>4.客户不承认之前提出来的需求，项目组又不能得失客户，项目成员苦不堪言。<br>5.需求经常变化，无法控制。<br>6.设计、代码与需求不对应，特别是需求变更时，不知道应该修改哪部分，也不知道会有哪些影响</p>
</blockquote>
<h4 id="优秀的需求管理要素："><a href="#优秀的需求管理要素：" class="headerlink" title="优秀的需求管理要素："></a>优秀的需求管理要素：</h4><blockquote>
<p>开发者应该理解需求</p>
<p>通过客户确认（记录）</p>
<p>需求变更管理（记录确认，影响清单确认）</p>
<p>需求双向跟踪维护（纵向：上下游工作产品之间的跟踪关系。横向：需求与需求之间的关系、设计与设计之前的关系、代码与代码之间的关系等）</p>
<p>需求与下游工作产品差异识别（需求变更时：双向跟踪表影响内容同步修改；编写写或者修改计划、设计、代码、测试计划、测试用例等需求下游工作产品时：要与需求保持一致）</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>工具赋能：</strong>需求管理平台&lt;-&gt;aido</p>
<h3 id="需求开发"><a href="#需求开发" class="headerlink" title="需求开发"></a>需求开发</h3><blockquote>
<p>用系统的方法获取真正的全面的能实现的需求</p>
</blockquote>
<h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote>
<p>没有把握好客户需求，直接进入软件的细节，去讨论要做什么功能，界面要怎样设计去了，而忘记了软件的根本目的是为了解决什么问题。</p>
</blockquote>
<p>明确客户需求后，就应该把客户需求转变成产品需求和产品组件需求，客户需求一般都是比较高层次的，而且描述也会比较简单，不能作为日后验收的标准，我们需要对软件的规格进行说明。一般来说，我们写的软件规格说明书都会包含产品需求和产品组件需求的。我们导出产品需求和产品组件需求的时候，要注意产品需求和产品组件需求，必须和客户需求对应起来，通常是多对多的关系。为什么要对应起来？我们要保证，软件的每一个界面，每一个功能都是有用的，都是“源自”客户需求的，这样才能保证我们做的事情都是正确的事情，防止被不相干的事情干扰。</p>
<p>客户需求</p>
<blockquote>
<p>可以理解成客户为什么要做本系统，要解决什么问题，客户对系统有怎样的期望，希望能具备一些怎样的特点，简单的说，就是客户的需要是什么。</p>
</blockquote>
<p>产品需求</p>
<blockquote>
<p>是能满足客户需求，并对软件产品规格进行了详细描述的需求，软件设计师可以根据产品需求进行设计、编码等工作。</p>
</blockquote>
<p>产品组件需求</p>
<blockquote>
<p>是对产品需求的进一步细化，产品可能会分割成几个子系统、几个部分，每个子系统每部分要具备怎样的功能、要具备怎样的性能、接口要求等，这些可以认为是产品组件需求。</p>
</blockquote>
<p>另外一个角度，需求可以分为功能性需求和非功能性需求两类，功能性需求就是系统具备怎样的功能，能做什么事情，而非功能性需求就是指系统要具备怎样的性能、安全级别等方面的要求。客户需求、产品需求和产品组件需求，都会包含功能需求和非功能需求。</p>
<h4 id="优秀的需求开发要素："><a href="#优秀的需求开发要素：" class="headerlink" title="优秀的需求开发要素："></a>优秀的需求开发要素：</h4><p>干系人的需要、期望、约束和接口要求被收集并转化为客户需求</p>
<blockquote>
<p>让客户能完整无遗漏准确地表达出他的想法：（原型、图示、类比、问卷）系统的目标、范围、解决什么问题、希望系统具备怎样的一些特性，满足一些什么接口要求和约束条件等</p>
<p>把客户原始的需求信息整理成正式的客户需求：通常会包括对系统目标、范围、解决问题、软件特性、接口要求等有详细的描述。</p>
</blockquote>
<p>客户需求是精确和详细的，以用来开发产品需求和产品组件需求</p>
<blockquote>
<p>产品和产品组件需求：对软件规格的描述，详细描述软件与用户是怎样交互的，用户需要输入什么，系统输出等都会比较详细描述出来。可做验收标准<br>分配需求给每一个产品组件：所有的需求应该与设计的产品组件对应，保证需求驱动后续的设计工作，同时也保证设计都是为需求服务</p>
<p>定义接口需求：包括系统与第三方的系统的接口要求，也包括系统本身各组件、各子系统、各部分之间的接口要求</p>
</blockquote>
<p>需求被分析和确认，并定义出具体的功能性需求</p>
<blockquote>
<p>操作场景与功能定义：描述出具体需求的操作场景、上下文，具体的操作步骤，对功能的详细描述等。通常我们可以通过序列图等来表达这些内容</p>
<p>分析需求：准确性、全面性、可实现性，平衡约束条件，确保需求符合最终的使用场景要求。通常是通过需求评审</p>
</blockquote>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><h4 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote>
<p>1)无设计文档<br>2)有设计文档，但形同虚设<br>3)设计时没有考虑可以重用以前项目或者第三方的代码或组件<br>4)没有用需求来驱动设计<br>5)设计没有考虑多过一个的方案<br>6)没有考虑清楚设计的原则和标准<br>7)设计的弹性不够、架构落后？<br>8)代码与设计脱节？<br>9)到处都是面条式代码</p>
</blockquote>
<h4 id="优秀的技术方案要素："><a href="#优秀的技术方案要素：" class="headerlink" title="优秀的技术方案要素："></a>优秀的技术方案要素：</h4><p>从候选方案中选择产品或者产品组件的解决方案</p>
<blockquote>
<p>先考虑好我们设计方案的选择标准，并找出可能的候选方案</p>
<p>对产品的规格进行详细的表述，操作概念、场景、环境、操作模式和操作状态等</p>
<p>根据选择标准选出最佳方案</p>
</blockquote>
<p>开发产品或者产品组件设计</p>
<blockquote>
<p>概要设计：建立产品功能和框架，包含产品组成区块、产品组件界定、系统状态与模式、主要的内外部接口和界面设计（功能模块设计、数据库设计包括逻辑设计和物理设计及安全性能设计、模块接口和界面设计）</p>
<p>详细设计：完整定义产品组件的结构和功能，详细描述实现方法、算法</p>
<p>建立和维护技术数据包：（需求、设计资料等）为开发者提供开发产品或组件的综合性描述，以及产品架构描述、分配需求、产品组件的描述、产品相关生命周期过程描述、关键产品特性、必需的物理特征和约束、接口需求、用于确保实现需求的验证准则等。</p>
<p>设计合适的产品组件接口：考虑外部接口和内部接口；与原来系统的关系；</p>
<p>产品组件开发、购买或者重用评估：技术状况</p>
</blockquote>
<p>实施产品组件的设计</p>
<blockquote>
<p>编码：适当的标准与准则，走查，单元测试</p>
<p>用户文档：用户手册、安装手册、管理员手册、在线帮助等</p>
</blockquote>
<h3 id="产品集成"><a href="#产品集成" class="headerlink" title="产品集成"></a>产品集成</h3><h4 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote>
<p>时序</p>
</blockquote>
<h4 id="优秀的产品集成要素："><a href="#优秀的产品集成要素：" class="headerlink" title="优秀的产品集成要素："></a>优秀的产品集成要素：</h4><p>完成产品集成的准备工作</p>
<blockquote>
<p>建立并维护产品组件的产品集成流程<br>建立并维护产品组件集成与评估标准<br>建立并维护产品组件的确认与交付标准</p>
</blockquote>
<p>确保产品内部与外部的接口是兼容的</p>
<blockquote>
<p>检查接口描述，保证覆盖性和完整性：通常通过评审接口说明。包括产品组件接口，产品集成所有环境的接口（定期）</p>
<p>管理产品和产品组件的内部和外部接口的定义、设计及变更：管理各组件之间的关系，保证组件间保持一致（配置库）</p>
</blockquote>
<p>组合已集成的产品组件，并交付已集成、已验证、已确认的产品</p>
<blockquote>
<p>在产品集成前，确定要集成的产品的产品组件已被确认、并依据其说明执行，并且确定产品集成接口符合接口说明</p>
<p>根据产品集成顺序和相关过程集成产品组件</p>
<p>评估产品组件的接口兼容性</p>
<p>打包组装已集成的产品或组件，并交付给适当的客户</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><strong>工具赋能</strong>：统一环境管理，持续集成，持续交付</p>
</div></div><a class="button-hover more" href="/bq/d22f4620.html#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2020 ～ 2022 By bq</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>